0x58DC60 4byte
object : 로케이션 넘버 * 5
나온 플레이어 값에 
+0좌 +2우 add → subtract←
+1상 +3하 add↓ subtract↑

n번째 로케이션의 왼쪽 위치는 0x58DC60 + n * 14h 입니다(n은 0부터 시작합니다) 
왼쪽 + 4h는 위, 
왼쪽 + 8h는 오른쪽, 
왼쪽 + Ch는 아래쪽입니다


p13 이상일 경우 플레이어 1, 유ID닛+1
★+0xF8 - WORD wRallyX
★+0xFA - WORD wRallyY
+0x34 - DWORD dwFlingySpeed
+0x48 ac


CUNIT STRUCT
+0x0 - CUNIT*Previous
+0x4 - CUNIT*Next
+0x8 - DWORD dwHP
+0xC - CSPRITE*sprite pointer 
	SPRITE pointer
	:+0x8 - 스프라이트 파일번호
	:+0xE - 체력바표시 on off (기본 9, 255시 제거)
	:+2C - 부가유닛 스프라이트 파일번호
+0x10 - WORD wMoveToXPos 
+0x12 - WORD wMoveToYPos
+0x14 - CUNIT*Target_1
+0x18 - WORD WCurrentXPos_?
+0x1A - WORD WCurrentYPos_?
+0x1C - WORD wX_?
+0x1E - WORD wY_?
+0x20 - BYTE bMovementFlags_?
2 - Making Building?
4 - Moving?

+0x22 - BYTE bFlingyTurnRadius
	:128이상부터 자동 회전현상 발생
	지상유닛인 경우는 전방향으로만 감.
+0x23 - BYTE bCurrentDirection_ 해당플레이어 방향
+0x24 - WORE wFlingyID
+0x27 - BYTE bFlingyMovementType
+0x28 - WORD wCurrentXPos
+0x2A - WORD wCurrentYPos
	: 0으로 하는 경우 유닛 그래픽은 존재하지만 선택되지 않으며 공격타겟으로도 설정되지 않음.
	부대지정해놓은 경우는 이동명령 가능, 스플래시도 맞지않음. 지상유닛은 이동불가.
+0x2C - DWORD dwX_Halt
+0x30 - DWORD dwY_Halt
+0x34 - DWORD dwFlingySpeed
+0x38 - DWORD dwUnknown_38_Speed
+0x3C - DWORD dwUnknown_3C_Speed

+0x48 - WORD wFlingyAcceleration

+0x4C - BYTE bPlayerID
+0x4D - BYTE bMainOrderID --명령상태
+0x4E - BYTE bMainOrderState
+0x4F - BYTE bOrderSignal

+0x54 - BYTE bMainOrderTimer
+0x55 - BYTE bGroundWeaponCooldown
+0x56 - BYTE bAirWeaponCooldown
+0x57 - BYTE bSpellCooldown
+0x58 - WORD wOrderTargetX
+0x5A - WORD wOrderTargetY
+0x5C - CUNIT*Target_Order
+0x60 - DWORD dwShield 해당유닛 현재 쉴드 수치
+0x64 - Word wUnitID 해당유닛아이디
+0x68 - CUNIT*PlayerPrevious
+0x6C - CUNIT*PlayerNext
+0x70 - CUNIT*Subunit
+0x74 - CORDER*OrderQueueHead
+0x78 - CORDER*OrderQueueTail

+0x7C - Unknown AI Cloak

+0x80 - CUNIT*ConnectedUnit

+0x84 -  BYTE bNumOfQueuedOrders
+0x85 - BYTE bUnknown_85_Order_Timer_Seperate

+0x88 - Word wDisplayerdUnitID?

+0x8E - BYTE bRankIncrease
+0x8F - BYTE bkillCount

+0x93 - BYTE bUnknownState?
+0x94 - BYTE bCurrentButtonSet
+0x98 - WORD wQueue1 /대기열 1 생성할 유닛 번호값이 있음
+0x9A - WORD wQueue2 /대기열 2 생성할 유닛 번호값이 있음
+0x9C - WORD wQueue3 /대기열 3 생성할 유닛 번호값이 있음
+0x9E - WORD wQueue4 /대기열 4 생성할 유닛 번호값이 있음
+0xA0 - WORD wQueue5 /대기열 5 생성할 유닛 번호값이 있음
+0xA2 - WORD wEnergy /필요없으나 위에 WQueue5의 데스 플레이어와 유닛 번호가 공유됨.
+0xA4 - BYTE bQueueSlot : 유닛을 생성할때 값이 38이 됨. 이때 대기열 1을 지우면 튕김

+0xA6 - BYTE bSecondaryOrderID
-Cloak,Build,expand creep
+0xA8 - WORD bHPGainDuringBuild/Repair?

+0xAC - WORD wRemainingBuildTime

UNION 
WORD
+0xC0 - BYTE bSpidermineCount
+0xC1 - BYTE bUnusedC1
+0xC2 - BYTE bUnusedC2
+0xC3 - BYTE bUnusedC3
CUNIT
+0xC0 - CUNIT*Unit_Unknown_1
IF Carrier/Reaver - First Hangar Unit
IF Scarab/Interceptor - Parent
IF Building - Addon
IF Worker - Powerup Carried
UNION 
WORD
+0xC4 - WORD wAddonBuildID
+0xC6 - WORD wUpgradeResearchTime
CUNIT*
+0xC4 - CUNIT*Unit_Unknown_2
IF Scarab/Interceptor - Next Unit in Parent Hangar
+0xC8 - BYTE bScarabCount/bTechID
+0xC9 - BYTE bInterceptorCount/bUpgradeID
+0xCA - BYTE bLarvaSpawnTimer
+0xCB - BYTE bIsLanding
CUNIT
+0xC8 - CUNIT*unit_Unknown_2
IF scarab/Interceptor -Previous in parent's Hamgar
+0xCC - BYTE b_Unknown
-IF interceptor/Scarab - InHanger?
-IF CreepUnit - timer between creep expansions
-IF Repairing - decrease mineral timer
+0xCD - BYTE bUpgradeLevel
+0xCE - BYTE bIsCarryingSomething?/Going to carry something?/Targeting Resources?
+0xCF - BYTE bResourceAmount
UNION 
WORD/BYTE
+0xD0 - WORD wResourceContained/wPowerupDropTargetX
+0xD2 - WORD wPowerupDropTargetY
+0xD2 - BYTE bResourceIscript
+0xD3 - BYTE bResourceCount?
DWORD 
+0xD0 - CUNIT ResourceTarget/NydusConnected
+0xD0 - CSPRITE NukeDot

+0xDC - DWORD dwStatus
00000001(0x1) - Is Completed
00000010(0x2) - Is on ground? or is it is unit..
00000100(0x4) - Is in air
00001000(0x8) - Checked for disabled, if it is 00001000, then the unit is disabled(/unpowered?)
00010000(0x10) - Checked for burrowing purposes, if it is 00010000, then the unit is burrowed
00100000(0x20) - Unit is entering a building
01000000(0x40) - unit is entering a transport
10000000(0x80) - 

00000001(0x100) -  Checked for invisible purposes, if it is 00000001, then unit requires a detector?
00000010(0x200) - checked for cloak?
00000100(0x400) - deals with doodad states? if set, is disabled
00001000(0x800) -  Unit cloaking doesn't need energy decrease
00010000(0x1000) - Unit is in unbreakable code section? Cannot receive orders
00100000(0x2000) - Set by nobrkcodestart
01000000(0x4000) - 
10000000(0x8000) - cannot attack if set

00000001(0x10000)
0000000(0x20000) - Is a Building?
0000000(0x40000)
0000000(0x80000) - Unit is Unmovable

0000000(0x4000000) - Invincible

0000000(0x10000000) - Speed upgrade
0000000(0x20000000) - cooldown Upgrade
0000000(0x40000000) - 

+0xE0 - BYTE bResouceType
+0xE1 - BYTE bWireframeRandomizer
+0xE2 - BYTE bSecondaryOrderState
+0xE3 - BYTE bUnknown_E3_Counter_Down

+0xEC - CUNIT*CurrentBuildUnit

UNION WORD / CUNIT
★+0xF8 - WORD wRallyX
★+0xFA - WORD wRallyY
+0xFC - CUNIT*RallyUnit
CUNIT
+0xF8 - CUNIT*PreviousPsiProvider
+0xFC - CUNIT*NextPsiProvider
+0x100 - DWORD 

+0x106 - BYTE bUnused_106
+0x107 - BYTE bIsBeingHealed
+0x108 - WORD wX_Contours_1_Unknown
+0x10A - WORD wY_Contours_1_Unknown
+0x10C - WORD wX_Contours_2_Unknown
+0x10E - WORD wY_Contours_2_Unknown
+0x110 - WORD wRemoveTimer
Hallucination, DSwarm, DWeb, Broodling
+0x112 - WORD wDMatrixDamage
+0x114 - BYTE bDMatrixTimer
+0x115 - BYTE bStimTimer
+0x116 - BYTE bEnsnareTimer
+0x117 - BYTE bLockdownTimer
+0x118 - BYTE bIrradiateTimer
+0x119 - BYTE bStatisTimer
+0x11A - BYTE bPlagueTimer
+0x11B - BYTE bIsUnderStorm
Used to tell if a unit is under psi storm
+0x11C - CUNIT*IrradiateBy
+0x120 - BYTE bIrradiatePlaterID
+0x121 - BYTE bParasiteFlags
Each bit corrisponds to the player who has parasited this unit
+0x122 - BYTE bCycleCounter
Runs updates 2 times per sec(abount)
+0x123 - BYTE blsBlind
+0x124 - BYTE bMaelstromCounter
+0x125 - bUnknown_Unreferenced
+0x126 - BYTE bAccidSporeCount
+0x127 - BYTE bAccidSpore1Time
+0x128 - BYTE bAccidSpore2Time
+0x129 - BYTE bAccidSpore3Time
+0x12A - BYTE bAccidSpore4Time
+0x12B - BYTE bAccidSpore5Time
+0x12C - BYTE bAccidSpore6Time
+0x12D - BYTE bAccidSpore7Time
+0x12E - BYTE bAccidSpore8Time
+0x12F - BYTE bAccidSpore9Time
+0x130 - WORD w3by3OffsetIndex
+0x132 - WORD wUnused_1325a
+0x134 - DWORD dwUnknown_
+0x138 - WORD wAirStrength(see eqation below, 1 if has no air weapon but has a ground)
+0x13A - WORD wGroundStrength(see equation below, 1 if has no ground weapon but has an air)
+0x13C - DWORD dwTableID_Unknown_1
+0x140 - DWORD dwTableID_Unknown_2
+0x144 - DWORD dwTableID_Unknown_3
+0x148 - DWORD dwTableID_Unknown_4
+0x14C - BYTE bRepulse_Unknown_1
+0x14D - BYTE bRepulse_Unknown_2
+0x14E - BYTE bDriftPosX(mapsizex/1.5 max)
+0x14F - BYTE bDriftPosY(mapsizey/1.5 max)

--------------------------------------------------------------------------
0x59CCA8 초기 메모리값
//This header file contains the binary layout of the CUnit structure.
//For the member functions, see CUnit.h
//Based on BWAPI's BW/CUnit.h

#include "Target.h"
#include "CList.h"

#pragma pack(1)

struct CImage;
struct CSprite;
struct COrder;
struct CUnit;

//Layout of the CUnit structure
//Comments marked with ++ added by RavenWolf
struct CUnitLayout {
/*0x000*/ CLink<CUnit> link;
/*0x008*/ s32   hitPoints;
/*0x00C*/ CSprite   *sprite;
/*0x00E*/ shadow x
/*0x00F*/ shadow y
/*0x010*/ TargetmoveTarget;   ///< The position or unit to move to. It is NOT an order target.
/*0x018*/ Point16   nextMovementWaypoint; ///< The next way point in the path the unit is following to get to its destination.
  ///< Equal to moveToPos for air units since they don't need to navigate around buildings.
/*0x01C*/ Point16   nextTargetWaypoint;   ///< The desired position
/*0x020*/ u8movementFlags;
/*0x021*/ u8currentDirection1;
/*0x022*/ 
	1~2byte u8flingyTurnSpeed;//AKA flingy turn radius 
	3~4byte suport unit direction(*65536)
	
/*0x023*/ u8velocityDirection1;
/*0x024*/ u16   flingyId;
/*0x026*/ u8_unknown_0x026;
/*0x027*/ u8flingyMovementType;
/*0x028*/ Point16   position;
/*0x02C*/ Point32   halt;
/*0x034*/ u32   flingyTopSpeed; //top speed 핑기 최고 속도
/*0x038*/ u32   current_speed1; //++current speed
/*0x03C*/ u32   current_speed2; //++not sure if there are any differences with these 2 variables, they always have the same value
/*0x040*/ Point32   current_velocity;
/*0x048*/ u16   flingyAcceleration; 핑기값 가속도
/*0x04A*/ u8currentDirection2;  //?
/*0x04B*/ u8velocityDirection2; //?

/*0x04C*/ u8playerId;
/*0x04D*/ u8mainOrderId;
/*0x04E*/ u8mainOrderState; //Used by various orders
/*0x04F*/ u8orderSignal;/*  0x01  Update building graphic/state
0x02  Casting spell
0x04  Reset collision? Always enabled for hallucination...
0x10  Lift/Land state
*/
/*0x050*/ u16   orderUnitType;
/*0x052*/ u16   _unknown_0x052; // 2-byte padding

/*0x054*/ u8mainOrderTimer;
/*0x055*/ u8groundWeaponCooldown;
/*0x056*/ u8airWeaponCooldown;
/*0x057*/ u8spellCooldown;
/*0x058*/ TargetorderTarget;

/*0x060*/ s32   shields;// Although BWAPI says this is unsigned, StarCraft.exe uses signed comparisons for this value
/*0x064*/ u16   id; // Unit ID in units.dat
/*0x066*/ u16   _unknown_0x066; // 2-byte padding
/*0x068*/ CLink<CUnit> player_link;
/*0x070*/ CUnit*subunit;
/*0x074*/ COrder*   orderQueueHead;
/*0x078*/ COrder*   orderQueueTail;
/*0x07C*/ CUnit*autoTargetUnit; //The auto-acquired target (Note: This field is actually used for different targets internally, especially by the AI)
/*0x080*/ CUnit*connectedUnit;  // ++Larva store a reference to the hatchery/Lair/Hive who created it
// ++units inside transports store a reference to the transport
// addons store a reference to its parent building (but not the other way around)
/*0x084*/ u8orderQueueCount;
/*0x085*/ u8orderQueueTimer;// Cycles down from from 8 to 0 (inclusive). See also 0x122.
/*0x086*/ u8_unknown_0x086;
/*0x087*/ u8attackNotifyTimer;  // Prevent "Your forces are under attack." on every attack
/*0x088*/ u16   displayedUnitId;//++used by zerg buildings while morphing
/*0x08A*/ u8lastEventTimer; // countdown that stops being recent when it hits 0
/*0x08B*/ u8lastEventColor; // 17 = was completed (train, morph), 174 = was attacked
/*0x08C*/ u16   _unknown_0x08C; // might have originally been RGB from lastEventColor
/*0x08E*/ u8rankIncrease;
/*0x08F*/ u8killCount;
/*0x090*/ u8lastAttackingPlayer;// the player that last attacked this unit
/*0x091*/ u8secondaryOrderTimer;
/*0x092*/ u8aiActionFlags;  // Used internally by the AI
/*0x093*/ u8userActionFlags;// some flags that change when the user interacts with the unit
// 2 = issued an order, 3 = interrupted an order, 4 = hide self before death
/*0x094*/ u16   currentButtonSet;   // The u16 is a guess, used to be u8
/*0x096*/ bool  isCloaked;
/*0x097*/ u8movementState;  // A value based on conditions related to pathing, see Path.h for info
/*0x098*/ u16   buildQueue[5];  //++train queue for buildings and carrier/reaver (stores the unitid) / zerg eggs stores the id of the morphing unit in queue[0]
/*0x0A2*/ u16   energy;
/*0x0A4*/ u8buildQueueSlot; //< Index of active unit in #buildQueue.
/*0x0A5*/ u8targetOrderSpecial; //< A byte used to determine the target ID for the unit
/*0x0A6*/ u8secondaryOrderId;
/*0x0A7*/ u8buildingOverlayState; // 0 means the building has the largest amount of fire/blood
/*0x0A8*/ u16   buildRepairHpGain;  //++hp ammount increased per frame when a unit/building its constructed/repaired
/*0x0AA*/ u16   _unknown_0x0AA;
/*0x0AC*/ u16   remainingBuildTime; //Remaining bulding time; also used by powerups (flags) as the timer for returning to their original location.
/*0x0AE*/ u16   previousHp; // The HP of the unit before it changed (example Drone->Hatchery, the Drone's HP will be stored here)
/*0x0B0*/ struct {
u16 index   : 11;   // 1-based index in the unit table.
u16 unitId  : 5;
  } loadedUnit[8];
/*0x0C0*/ union {
struct {
/*0x0C0*/ u8 spiderMineCount;
} vulture;

struct {
/*0x0C0*/ CUnit*  inHangarChild;// First child inside the hanger
/*0x0C4*/ CUnit*  outHangarChild;   // First child outside the hanger
/*0x0C8*/ u8  inHangarCount;// Number inside the hanger
/*0x0C9*/ u8  outHangarCount;   // Number outside the hanger
} carrier; // also applies to reaver

struct {
/*0x0C0*/ CUnit*  parent;
/*0x0C4*/ CLink<CUnit> hangar_link;
/*0x0CC*/ boolisOutsideHangar;
} interceptor;  // also applies to scarab

struct {
/*0x0C0*/ u32 _unknown_00;
/*0x0C4*/ u32 _unknown_04;
/*0x0C8*/ u32 flagSpawnFrame; // flag beacons, the frame that the flag will spawn
} beacon;

struct {
/*0x0C0*/ CUnit*  addon;
/*0x0C4*/ u16 addonBuildType;
/*0x0C6*/ u16 upgradeResearchTime;
/*0x0C8*/ u8  techType;
/*0x0C9*/ u8  upgradeType;
/*0x0CA*/ u8  larvaTimer;
/*0x0CB*/ u8  landingTimer;
/*0x0CC*/ u8  creepTimer;
/*0x0CD*/ u8  upgradeLevel;
/*0x0CE*/ u16 _padding_0E;
/*0x0D0*/ union {
struct {
/*0x0D0*/ u16   resourceAmount;
/*0x0D2*/ u8resourceIscript;
/*0x0D3*/ u8gatherQueueCount;
/*0x0D4*/ CUnit*nextGatherer;   // pointer to the next worker unit waiting in line to gather
/*0x0D8*/ u8resourceGroup;  
/*0x0D9*/ u8resourceBelongsToAI;
} resource;  /** When the unit is resource container */
CUnit*nydusExit; /** connected nydus canal */
CUnit*ghostNukeMissile; //Tentative
CSprite*  pylonAura;
struct {
/*0x0D0*/ CUnit*  nuke;  // attached nuke
/*0x0D4*/ boolisReady;
} silo;
Box16 hatcheryHarvestValue; // wtf???
Point16   powerupOrigin;
  };
} building;

struct {
/*0x0C0*/ CUnit*  powerup;
/*0x0C4*/ Target  targetResource;
/*0x0CC*/ u16 repairResourceLossTimer;
/*0x0CE*/ boolisCarryingSomething;
/*0x0CF*/ u8  resourceCarryAmount;
/*0x0D0*/ CUnit*  harvestTarget;
/*0x0D4*/ CLink<CUnit> harvest_link;  // When there is a gather conflict
} worker;
  };

/*0x0DC*/ u32   status; // See UnitStatus:: 1 2 4 8 

/*0x0E0*/ u8resourceType;   // Type of resource chunk carried by this worker. 1 = vespene gas, 2 = mineral.
/*0x0E1*/ u8wireframeRandomizer;
/*0x0E2*/ u8secondaryOrderState;
/*0x0E3*/ u8recentOrderTimer;   // Counts down from 15 to 0 when most orders are given, or when the unit moves after reaching a patrol location
/*0x0E4*/ s32   visibilityStatus;   // Flags specifying which players can detect this unit (cloaked/burrowed)
/*0x0E8*/ Point16   secondaryOrderPos;
/*0x0EC*/ CUnit*currentBuildUnit;
/*0x0F0*/ CLink<CUnit> burrow_link;
/*0x0F8*/ union {
Target rally;
CLink<CUnit> psi_link;
  };
/*0x100*/ void* path;
/*0x104*/ u8pathingCollisionInterval;  // unknown
/*0x105*/ u8pathingFlags;   // 0x01 = uses pathing; 0x02 = ?; 0x04 = ?
/*0x106*/ u8_unused_0x106;
/*0x107*/ bool  isBeingHealed;
/*0x108*/ Box16 contourBounds;  // A rect that specifies the closest contour (collision) points

/*0x110*/ u16   removeTimer;// Hallucination, Dark Swarm, Disruption Web, Broodling
/*0x112*/ u16   defensiveMatrixHp;
/*0x114*/ u8defensiveMatrixTimer;
/*0x115*/ u8stimTimer;
/*0x116*/ u8ensnareTimer;
/*0x117*/ u8lockdownTimer;
/*0x118*/ u8irradiateTimer;
/*0x119*/ u8stasisTimer;
/*0x11A*/ u8plagueTimer;
/*0x11B*/ u8isUnderStorm;   // Used to tell if a unit is under psi storm
/*0x11C*/ CUnit*irradiatedBy;
/*0x120*/ u8irradiatePlayerId;
/*0x121*/ u8parasiteFlags;  // Each bit corrisponds to the player who has parasited this unit*/
/*0x122*/ u8cycleCounter;   // counts/cycles up from 0 to 7 (inclusive).
/*0x123*/ u8isBlind;
/*0x124*/ u8maelstromTimer;
/*0x125*/ u8unusedTimer;// ?? Might be afterburner timer or ultralisk roar timer
/*0x126*/ u8acidSporeCount;
/*0x127*/ u8acidSporeTime[9];
/*0x130*/ u16   offsetIndex3by3;// Cycles between 0-12 for each bullet fired by this unit (if it uses a "Attack 3x3 area" weapon)
/*0x132*/ u16   _padding_0x132;
/*0x134*/ void* pAI;
/*0x138*/ u16   airStrength;
/*0x13A*/ u16   groundStrength;
/*0x13C*/ struct { u32 left, right, top, bottom; } finderIndex;  // Ordering for unit boundries in unit finder for binary search
/*0x14C*/ u8repulseUnknown;
/*0x14D*/ u8repulseAngle;   // updated only when air unit is being pushed
/*0x14E*/ Point8driftPos;   // (mapsizex / 1.5 max)
};

static_assert(sizeof(CUnitLayout) == 336, "The size of the CUnitLayout structure is invalid");

#pragma pack()
-----------------------------------------------------------------------------------------------------------


 
// v-- POSSIBLE SHARED BULLET/UNIT STRUCTURE BEGIN
// CLink<CUnit> link;
/*0x000*/ BW::CUnit *prev;
/*0x004*/ BW::CUnit *next;  /**< Pointer to next unit in the unit linked list, we use
  *   it to iterate units.
  *   @see BW#BWXFN_UnitNodeTable_FirstElement
  **/
/*0x008*/ s32   hitPoints;  // Hit points of unit, note that the displayed value in broodwar is ceil(healthPoints/256)
// Officially called "xLife"
/*0x00C*/ BW::CSprite   *sprite;
// One of these Position structs are just called "swLocX" and "swLocY"
/*0x010*/ BW::TargetmoveTarget; // The position or unit to move to. It is NOT an order target.
/*0x018*/ BW::Position  nextMovementWaypoint;   /**< The next way point in the path the unit is following to get to its destination.
  * Equal to moveToPos for air units since they don't need to navigate around buildings
  * or other units.
  */
/*0x01C*/ BW::Position  nextTargetWaypoint;   // The desired position
/*0x020*/ u8movementFlags;// Flags specifying movement type - defined in BW#MovementFlags.
/*0x021*/ u8currentDirection1;// The current direction the unit is facing
/*0x022*/ u8flingyTurnRadius;
/*0x023*/ u8velocityDirection1;  /**< This usually only differs from the currentDirection field for units that can accelerate
 *   and travel in a different direction than they are facing. For example Mutalisks can change
 *   the direction they are facing faster than then can change the direction they are moving.
 */
/*0x024*/ u16   flingyID;
/*0x026*/ u8_unknown_0x026;
/*0x027*/ u8flingyMovementType;
/*0x028*/ BW::Position  position; // Current position of the unit
/*0x02C*/ POINT halt; // @todo Unknown// Either this or current_speed is officially called "xDX, xDY" (no POINT struct)
/*0x034*/ u32   flingyTopSpeed;
/*0x038*/ s32   current_speed1;
/*0x03C*/ s32   current_speed2;
/*0x040*/ POINT current_speed;
/*0x048*/ u16   flingyAcceleration;
/*0x04A*/ u8currentDirection2;
/*0x04B*/ u8velocityDirection2;   // pathing related, gets this value from Path::unk_1A?
/*0x04C*/ u8playerID; // Specification of owner of this unit.
/*0x04D*/ u8orderID;  // Specification of type of order currently given.
/*0x04E*/ u8orderState;  //< Additional order info (mostly unknown, wander property investigated so far)  // officially "ubActionState"
 /*  0x01  Moving/Following Order
 0x02  No collide (Larva)?
 0x04  Harvesting? Working?
 0x08  Constructing Stationary
 Note: I don't actually think these are flags
   */
/*0x04F*/ u8orderSignal;  /*  0x01  Update building graphic/state
  0x02  Casting spell
  0x04  Reset collision? Always enabled for hallucination...
  0x10  Lift/Land state
  */
/*0x050*/ u16   orderUnitType;  // officially "uwFoggedTarget"
u16 __0x52;  // 2-byte padding
/*0x054*/ u8mainOrderTimer;   // A timer for orders, example: time left before minerals are harvested
/*0x055*/ u8groundWeaponCooldown;
/*0x056*/ u8airWeaponCooldown;
/*0x057*/ u8spellCooldown;
/*0x058*/ BW::TargetorderTarget;// officially called ActionFocus
// ^-- POSSIBLE SHARED BULLET/UNIT STRUCTURE END
/*0x060*/ u32 shieldPoints;  // BW shows this value/256, possibly not u32?
/*0x064*/ u16 unitType;// Specifies the type of unit.
u16 __0x66;  // 2-byte padding
// CLink<CUnit> player_link;
/*0x068*/ BW::CUnit   *previousPlayerUnit;
/*0x06C*/ BW::CUnit   *nextPlayerUnit;
/*0x070*/ BW::CUnit   *subUnit;
// CLink<COrder> orderQueue_link;
/*0x074*/ BW::COrder   *orderQueueHead;
/*0x078*/ BW::COrder   *orderQueueTail;
/*0x07C*/ BW::CUnit   *autoTargetUnit;  // The auto-acquired target (Note: This field is actually used for different targets internally, especially by the AI)
/*0x080*/ BW::CUnit   *connectedUnit;   // Addon is connected to building (addon has conntected building, but not in other direction  (officially "pAttached")
/*0x084*/ u8  orderQueueCount;  // @todo Verify   // officially "ubQueuedOrders"
/*0x085*/ u8  orderQueueTimer;  // counts/cycles down from from 8 to 0 (inclusive). See also 0x122.
/*0x086*/ u8  _unknown_0x086;   // pathing related?
/*0x087*/ u8  attackNotifyTimer;// Prevent "Your forces are under attack." on every attack
/*0x088*/ u16 displayedUnitID;
/*0x08A*/ u8  lastEventTimer;   // countdown that stops being recent when it hits 0 
/*0x08B*/ u8  lastEventColor;   // 17 = was completed (train, morph), 174 = was attacked
/*0x08C*/ u16 _unused_0x08C;// might have originally been RGB from lastEventColor
/*0x08E*/ u8  rankIncrease; // Adds this value to the unit's base rank
/*0x08F*/ u8  killCount;// Killcount
/*0x090*/ u8  lastAttackingPlayer;  // the player that last attacked this unit
/*0x091*/ u8  secondaryOrderTimer;
/*0x092*/ u8  AIActionFlag;   // Internal use by AI only
/*0x093*/ u8  userActionFlags;// some flags that change when the user interacts with the unit
  // 2 = issued an order, 3 = interrupted an order, 4 = self destructing
/*0x094*/ u16 currentButtonSet;   // The u16 is a guess, used to be u8
/*0x096*/ boolisCloaked
/*0x097*/ u8  movementState;  // A value based on conditions related to pathing, see Path.h for info
/*0x098*/ u16 buildQueue[5];  //< Queue of units to build. Note that it doesn't begin with index 0, but with #buildQueueSlot index. 
/*0x0A2*/ u16 energy; //< Energy Points   // officially "xwMagic"
/*0x0A4*/ u8  buildQueueSlot; //< Index of active unit in #buildQueue. 
/*0x0A5*/ u8  targetOrderSpecial; //< A byte used to determine the target ID for the unit 
/*0x0A6*/ u8  secondaryOrderID;   //< (Build addon verified) @todo verify (Cloak, Build, ExpandCreep suggested by EUDDB) 
/*0x0A7*/ u8  buildingOverlayState;   // 0 means the building has the largest amount of fire/blood
/*0x0A8*/ u16 hpGainDuringRepair; //< @todo Verify 
/*0x0AA*/ u16 _unknown_0x0AA;
/*0x0AC*/ u16 remainingBuildTime; //< Remaining bulding time; This is also the timer for powerups (flags) to return to their original location.
/*0x0AE*/ u16 previousHP; // The HP of the unit before it changed (example Drone->Hatchery, the Drone's HP will be stored here)
/*0x0B0*/ u16 loadedUnitIndex[8]; // officially called "uwTransport[8]"
/*0x0C0*/ union
  {
struct
{
  u8 spiderMineCount; // 0
} vulture;
struct
{
  BW::CUnit *pInHanger; // 0   first child inside the hanger// official
  BW::CUnit *pOutHanger;// 4   first child outside the hanger
  u8inHangerCount;  // 8   number inside the hanger
  u8outHangerCount; // 9   number outside the hanger
} carrier; // also applies to reaver (Carrier is official)
struct
{
  BW::CUnit  *parent;// 0
  // CLink<CUnit> hanger_link;
  BW::CUnit  *prev;  // 4
  BW::CUnit  *next;  // 8
  bool   inHanger;   // C
} fighter;  // also applies to scarab
struct
{
  u32 _unknown_00;
  u32 _unknown_04;
  u32 flagSpawnFrame; // flag beacons, the frame that the flag will spawn
} beacon;
struct
{
  BW::CUnit *addon;   // 0
  u16   addonBuildType;   // 4
  u16   upgradeResearchTime;  // 6
  u8techType; // 8
  u8upgradeType;  // 9
  u8larvaTimer;   // A
  u8landingTimer; // B
  u8creepTimer;   // C
  u8upgradeLevel; // D
  u16 __E;  // 2-byte padding
  union   // 10
  { 
struct
{ u16   resourceCount;  // amount of resources
  u8resourceIscript;
  u8gatherQueueCount;
  BW::CUnit *nextGatherer;// 14  // pointer to the next workerunit waiting in line to gather
  u8resourceGroup;// 18
  u8resourceBelongsToAI;
} resource;  // When the unit is resource container
struct { BW::CUnit*exit; } nydus; // connected nydius canal
struct { BW::CSprite  *nukeDot; } ghost;
struct { BW::CSprite  *pylonAura; } pylon;  // Should be "CUnit::Pylon::pPowerTemplate"
struct
{ BW::CUnit *pNuke;   // attached nuke// official name
  bool bReady;  // 14   // official name
} silo;   // Should be "CUnit::Silo::"
struct
{ ::rect harvestValue;
} hatchery; // wtf???
struct { POINTS origin; } powerup;
  };
} building;
struct 
{
  BW::CUnit *pPowerup;// 0// official
  POINTStargetResource;   // 4
  BW::CUnit *targetResourceUnit;  // 8
  u16   repairResourceLossTimer;  // C
  bool  isCarryingSomething;  // E// There is a "ubIsHarvesting" somewhere
  u8resourceCarryCount;   // F
  BW::CUnit *harvestTarget;   // 10
  // CLINK<CUnit> harvest_link;
  BW::CUnit *prevHarvestUnit; // 14   // When there is a gather conflict
  BW::CUnit *nextHarvestUnit; // 18
} worker;   // Official name, but there is also a "CUnit::WorkerList::pHarvestBldg" somewhere
  };
/*0x0DC*/ u32   statusFlags;
/*0x0E0*/ u8resourceType; // Resource being held by worker: 1 = gas, 2 = ore
/*0x0E1*/ u8wireframeRandomizer;
/*0x0E2*/ u8secondaryOrderState;
/*0x0E3*/ u8recentOrderTimer; // Counts down from 15 to 0 when most orders are given,
  // or when the unit moves after reaching a patrol location
/*0x0E4*/ s32   visibilityStatus; // Flags specifying which players can detect this unit (cloaked/burrowed)
/*0x0E8*/ u16   _unknown_0x0E8;   // Secondary order related (x?)
/*0x0EA*/ u16   _unknown_0x0EA;   // Secondary order related (y?)
/*0x0EC*/ BW::CUnit *currentBuildUnit;
// CLink<CUnit> burrow_link;
/*0x0F0*/ BW::CUnit *previousBurrowedUnit;
/*0x0F4*/ BW::CUnit *nextBurrowedUnit;
/*0x0F8*/ union
{ struct
  { POINTSposition;
BW::CUnit *unit;
  } rally;  // If the unit is rally type
  struct
  { // CLink<CUnit> power_link;
BW::CUnit *prevPsiProvider;
BW::CUnit *nextPsiProvider;
  } pylon;  // If the unit is psi provider
};
/*0x100*/ BW::Path  *path;// officially "unitPath"
/*0x104*/ u8pathingCollisionInterval; // unknown
/*0x105*/ u8pathingFlags; // 0x01 = uses pathing; 0x02 = ?; 0x04 = ?
/*0x106*/ u8_unused_0x106;
/*0x107*/ bool  isBeingHealed;// 1 if a medic is currently healing this unit
/*0x108*/ rect  contourBounds;// a rect that specifies the closest contour (collision) points
struct
{
  /*0x110*/ u16   removeTimer;  //  does not apply to scanner sweep
  /*0x112*/ u16   defenseMatrixDamage;
  /*0x114*/ u8defenseMatrixTimer;
  /*0x115*/ u8stimTimer;
  /*0x116*/ u8ensnareTimer;
  /*0x117*/ u8lockdownTimer;
  /*0x118*/ u8irradiateTimer;
  /*0x119*/ u8stasisTimer;
  /*0x11A*/ u8plagueTimer;
  /*0x11B*/ u8stormTimer;
  /*0x11C*/ BW::CUnit *irradiatedBy;
  /*0x120*/ u8irradiatePlayerID;
  /*0x121*/ u8parasiteFlags;
  /*0x122*/ u8cycleCounter; // counts/cycles up from 0 to 7 (inclusive). See also 0x85.
  /*0x123*/ bool  isBlind;
  /*0x124*/ u8maelstromTimer;
  /*0x125*/ u8_unused_0x125;// ?? Might be afterburner timer or ultralisk roar timer
  /*0x126*/ u8acidSporeCount;
  /*0x127*/ u8acidSporeTime[9];
} status;
/*0x130*/ u16   bulletBehaviour3by3AttackSequence;  // Counts up for the number of bullets shot by a unit using
// this weapon behaviour and resets after it reaches 12
u16   _padding_0x132;   // 2-byte padding
/*0x134*/ void  *pAI;// pointer to AI class, we're not using this though  // official name
/*0x138*/ u16   airStrength;
/*0x13A*/ u16   groundStrength;
struct
{ // Official names are "posSortXL, posSortXR, posSortYT, posSortYB"
  u32 left, right, top, bottom; // Ordering for unit boundries in unit finder for binary search
} finder;
/*0x14C*/ u8_repulseUnknown;// @todo Unknown
/*0x14D*/ u8repulseAngle;   // updated only when air unit is being pushed
/*0x14E*/ u8driftPosX;  //  (mapsizex/1.5 max)// officially "bRepMtxX"   // repulse matrix X/Y
/*0x14F*/ u8driftPosY;  //  (mapsizex/1.5 max)// "bRepMtxY" 

-------------------------------------------------------------------------------------
#pragma once

#include <Util/Types.h>
#include <BW/Position.h>
#include <BW/Offsets.h>
#include <BW/Target.h>

#pragma pack(1)
namespace BWAPI
{
  class UnitType;
}
namespace BW
{
  // Forwards
  class Sprite;
  class COrder;
  struct Path;  

  /** Broodwar CUnit class.
   * Started from http://farty1billion.dyndns.org/EUDDB/?pg=ref&a=unitnode
   * Heavily altered and corrected.
   * Most members are known, including some padding/alignment bytes that have been identified.
   * Members that are marked as "unknown", "todo", "maybe", etc. must still be researched.
   *
   * The Broodwar project has a 4-byte alignment, this structure follows that directive and
   * excludes some bytes that have been marked as padding bytes.
   *
   * Additional notes: possibly missing a "Cloaked" link, has a static member "nSorted"
   */
  class CUnit
  {
  public:
    BWAPI::UnitType type() const;
    bool movementFlag(u8 flags) const;
    bool statusFlag(u32 flags) const;

// v-- POSSIBLE SHARED BULLET/UNIT STRUCTURE BEGIN
// CLink<CUnit> link;
/*0x000*/ BW::CUnit     *prev;
/*0x004*/ BW::CUnit     *next;  /**< Pointer to next unit in the unit linked list, we use
                                          *   it to iterate units.
                                          *   @see BW#BWXFN_UnitNodeTable_FirstElement
                                          **/
/*0x008*/ s32           hitPoints;  // Hit points of unit, note that the displayed value in broodwar is ceil(healthPoints/256)
                                    // Officially called "xLife"
/*0x00C*/ BW::CSprite   *sprite;
                                                // One of these Position structs are just called "swLocX" and "swLocY"
/*0x010*/ BW::Target    moveTarget;         // The position or unit to move to. It is NOT an order target.
/*0x018*/ BW::Position  nextMovementWaypoint;   /**< The next way point in the path the unit is following to get to its destination.
                                                      * Equal to moveToPos for air units since they don't need to navigate around buildings
                                                      * or other units.
                                                      */
/*0x01C*/ BW::Position  nextTargetWaypoint;   // The desired position
/*0x020*/ u8            movementFlags;    // Flags specifying movement type - defined in BW#MovementFlags.
/*0x021*/ u8            currentDirection1;// The current direction the unit is facing
/*0x022*/ u8            flingyTurnRadius;
/*0x023*/ u8            velocityDirection1;  /**< This usually only differs from the currentDirection field for units that can accelerate
                                                 *   and travel in a different direction than they are facing. For example Mutalisks can change
                                                 *   the direction they are facing faster than then can change the direction they are moving.
                                                 */
/*0x024*/ u16           flingyID;
/*0x026*/ u8            _unknown_0x026;
/*0x027*/ u8            flingyMovementType;
/*0x028*/ BW::Position  position;     // Current position of the unit
/*0x02C*/ POINT         halt;         // @todo Unknown// Either this or current_speed is officially called "xDX, xDY" (no POINT struct)
/*0x034*/ u32           flingyTopSpeed;
/*0x038*/ s32           current_speed1;
/*0x03C*/ s32           current_speed2;
/*0x040*/ POINT         current_speed;

/*0x048*/ u16           flingyAcceleration;
/*0x04A*/ u8            currentDirection2;
/*0x04B*/ u8            velocityDirection2;   // pathing related, gets this value from Path::unk_1A?
/*0x04C*/ u8            playerID;         // Specification of owner of this unit.
/*0x04D*/ u8            orderID;          // Specification of type of order currently given.
/*0x04E*/ u8            orderState;  //< Additional order info (mostly unknown, wander property investigated so far)  // officially "ubActionState"
                                     /*  0x01  Moving/Following Order
                                             0x02  No collide (Larva)?
                                             0x04  Harvesting? Working?
                                             0x08  Constructing Stationary
                                             Note: I don't actually think these are flags
                                           */
/*0x04F*/ u8            orderSignal;  /*  0x01  Update building graphic/state
                                              0x02  Casting spell
                                              0x04  Reset collision? Always enabled for hallucination...
                                              0x10  Lift/Land state
                                          */
/*0x050*/ u16           orderUnitType;  // officially "uwFoggedTarget"
    
    u16 __0x52;  // 2-byte padding

/*0x054*/ u8            mainOrderTimer;   // A timer for orders, example: time left before minerals are harvested
/*0x055*/ u8            groundWeaponCooldown;
/*0x056*/ u8            airWeaponCooldown;
/*0x057*/ u8            spellCooldown;
/*0x058*/ BW::Target    orderTarget;    // officially called ActionFocus
// ^-- POSSIBLE SHARED BULLET/UNIT STRUCTURE END

/*0x060*/ u32         shieldPoints;  // BW shows this value/256, possibly not u32?
/*0x064*/ u16         unitType;    // Specifies the type of unit.
    
    u16 __0x66;  // 2-byte padding

// CLink<CUnit> player_link;
/*0x068*/ BW::CUnit   *previousPlayerUnit;
/*0x06C*/ BW::CUnit   *nextPlayerUnit;

/*0x070*/ BW::CUnit   *subUnit;

// CLink<COrder> orderQueue_link;
/*0x074*/ BW::COrder   *orderQueueHead;
/*0x078*/ BW::COrder   *orderQueueTail;

/*0x07C*/ BW::CUnit   *autoTargetUnit;  // The auto-acquired target (Note: This field is actually used for different targets internally, especially by the AI)
/*0x080*/ BW::CUnit   *connectedUnit;   // Addon is connected to building (addon has conntected building, but not in other direction  (officially "pAttached")
/*0x084*/ u8          orderQueueCount;  // @todo Verify   // officially "ubQueuedOrders"
/*0x085*/ u8          orderQueueTimer;  // counts/cycles down from from 8 to 0 (inclusive). See also 0x122.
/*0x086*/ u8          _unknown_0x086;   // pathing related?
/*0x087*/ u8          attackNotifyTimer;// Prevent "Your forces are under attack." on every attack
/*0x088*/ u16         displayedUnitID;
/*0x08A*/ u8          lastEventTimer;   // countdown that stops being recent when it hits 0 
/*0x08B*/ u8          lastEventColor;   // 17 = was completed (train, morph), 174 = was attacked
/*0x08C*/ u16         _unused_0x08C;    // might have originally been RGB from lastEventColor
/*0x08E*/ u8          rankIncrease;     // Adds this value to the unit's base rank
/*0x08F*/ u8          killCount;        // Killcount
/*0x090*/ u8          lastAttackingPlayer;  // the player that last attacked this unit
/*0x091*/ u8          secondaryOrderTimer;
/*0x092*/ u8          AIActionFlag;       // Internal use by AI only
/*0x093*/ u8          userActionFlags;    // some flags that change when the user interacts with the unit
                                              // 2 = issued an order, 3 = interrupted an order, 4 = self destructing

/*0x094*/ u16         currentButtonSet;   // The u16 is a guess, used to be u8
/*0x096*/ bool        isCloaked;
/*0x097*/ u8          movementState;      // A value based on conditions related to pathing, see Path.h for info
/*0x098*/ u16         buildQueue[5];      //< Queue of units to build. Note that it doesn't begin with index 0, but with #buildQueueSlot index. 
/*0x0A2*/ u16         energy;             //< Energy Points   // officially "xwMagic"
/*0x0A4*/ u8          buildQueueSlot;     //< Index of active unit in #buildQueue. 
/*0x0A5*/ u8          targetOrderSpecial; //< A byte used to determine the target ID for the unit 
/*0x0A6*/ u8          secondaryOrderID;   //< (Build addon verified) @todo verify (Cloak, Build, ExpandCreep suggested by EUDDB) 
/*0x0A7*/ u8          buildingOverlayState;   // 0 means the building has the largest amount of fire/blood
/*0x0A8*/ u16         hpGainDuringRepair; //< @todo Verify 
/*0x0AA*/ u16         _unknown_0x0AA;
/*0x0AC*/ u16         remainingBuildTime; //< Remaining bulding time; This is also the timer for powerups (flags) to return to their original location.
/*0x0AE*/ u16         previousHP;         // The HP of the unit before it changed (example Drone->Hatchery, the Drone's HP will be stored here)
/*0x0B0*/ u16         loadedUnitIndex[8]; // officially called "uwTransport[8]"
/*0x0C0*/ union
              {
                struct
                {
                  u8 spiderMineCount; // 0
                } vulture;
                
                struct
                {
                  BW::CUnit *pInHanger; // 0   first child inside the hanger// official
                  BW::CUnit *pOutHanger;// 4   first child outside the hanger
                  u8        inHangerCount;  // 8   number inside the hanger
                  u8        outHangerCount; // 9   number outside the hanger
                } carrier; // also applies to reaver (Carrier is official)
                
                struct
                {
                  BW::CUnit  *parent;// 0
              // CLink<CUnit> hanger_link;
                  BW::CUnit  *prev;  // 4
                  BW::CUnit  *next;  // 8
                  bool       inHanger;   // C
                } fighter;  // also applies to scarab
                
                struct
                {
                  u32 _unknown_00;
                  u32 _unknown_04;
                  u32 flagSpawnFrame; // flag beacons, the frame that the flag will spawn
                } beacon;

                struct
                {
                  BW::CUnit *addon;           // 0
                  u16       addonBuildType;   // 4
                  u16       upgradeResearchTime;  // 6
                  u8        techType;         // 8
                  u8        upgradeType;      // 9
                  u8        larvaTimer;       // A
                  u8        landingTimer;     // B
                  u8        creepTimer;       // C
                  u8        upgradeLevel;     // D
                  u16 __E;  // 2-byte padding
                  union                       // 10
                  { 
                    struct
                    { u16       resourceCount;  // amount of resources
                      u8        resourceIscript;
                      u8        gatherQueueCount;
                      BW::CUnit *nextGatherer;// 14  // pointer to the next workerunit waiting in line to gather
                      u8        resourceGroup;// 18
                      u8        resourceBelongsToAI;
                    } resource;  // When the unit is resource container
                    struct { BW::CUnit    *exit; } nydus; // connected nydius canal
                    struct { BW::CSprite  *nukeDot; } ghost;
                    struct { BW::CSprite  *pylonAura; } pylon;  // Should be "CUnit::Pylon::pPowerTemplate"
                    struct
                    { BW::CUnit *pNuke;   // attached nuke// official name
                      bool bReady;  // 14   // official name
                    } silo;   // Should be "CUnit::Silo::"
                    struct
                    { ::rect harvestValue;
                    } hatchery; // wtf???
                    struct { POINTS origin; } powerup;
                  };
                } building;
                
                struct 
                {
                  BW::CUnit *pPowerup;            // 0// official
                  POINTS    targetResource;       // 4
                  BW::CUnit *targetResourceUnit;  // 8
                  u16       repairResourceLossTimer;  // C
                  bool      isCarryingSomething;  // E// There is a "ubIsHarvesting" somewhere
                  u8        resourceCarryCount;   // F
                  BW::CUnit *harvestTarget;       // 10
              // CLINK<CUnit> harvest_link;
                  BW::CUnit *prevHarvestUnit;     // 14   // When there is a gather conflict
                  BW::CUnit *nextHarvestUnit;     // 18
                } worker;   // Official name, but there is also a "CUnit::WorkerList::pHarvestBldg" somewhere
              };
/*0x0DC*/ u32       statusFlags;
/*0x0E0*/ u8        resourceType;     // Resource being held by worker: 1 = gas, 2 = ore
/*0x0E1*/ u8        wireframeRandomizer;
/*0x0E2*/ u8        secondaryOrderState;
/*0x0E3*/ u8        recentOrderTimer; // Counts down from 15 to 0 when most orders are given,
                                          // or when the unit moves after reaching a patrol location
/*0x0E4*/ s32       visibilityStatus; // Flags specifying which players can detect this unit (cloaked/burrowed)
/*0x0E8*/ u16       _unknown_0x0E8;   // Secondary order related (x?)
/*0x0EA*/ u16       _unknown_0x0EA;   // Secondary order related (y?)
/*0x0EC*/ BW::CUnit *currentBuildUnit;
// CLink<CUnit> burrow_link;
/*0x0F0*/ BW::CUnit *previousBurrowedUnit;
/*0x0F4*/ BW::CUnit *nextBurrowedUnit;
/*0x0F8*/ union
        { struct
          { POINTS    position;
            BW::CUnit *unit;
          } rally;  // If the unit is rally type

          struct
          { // CLink<CUnit> power_link;
            BW::CUnit *prevPsiProvider;
            BW::CUnit *nextPsiProvider;
          } pylon;  // If the unit is psi provider
        };
/*0x100*/ BW::Path  *path;// officially "unitPath"
/*0x104*/ u8        pathingCollisionInterval; // unknown
/*0x105*/ u8        pathingFlags;         // 0x01 = uses pathing; 0x02 = ?; 0x04 = ?
/*0x106*/ u8        _unused_0x106;
/*0x107*/ bool      isBeingHealed;// 1 if a medic is currently healing this unit
/*0x108*/ rect      contourBounds;// a rect that specifies the closest contour (collision) points
    struct
    {
  /*0x110*/ u16       removeTimer;  //  does not apply to scanner sweep
  /*0x112*/ u16       defenseMatrixDamage;
  /*0x114*/ u8        defenseMatrixTimer;
  /*0x115*/ u8        stimTimer;
  /*0x116*/ u8        ensnareTimer;
  /*0x117*/ u8        lockdownTimer;
  /*0x118*/ u8        irradiateTimer;
  /*0x119*/ u8        stasisTimer;
  /*0x11A*/ u8        plagueTimer;
  /*0x11B*/ u8        stormTimer;
  /*0x11C*/ BW::CUnit *irradiatedBy;
  /*0x120*/ u8        irradiatePlayerID;
  /*0x121*/ u8        parasiteFlags;
  /*0x122*/ u8        cycleCounter; // counts/cycles up from 0 to 7 (inclusive). See also 0x85.
  /*0x123*/ bool      isBlind;
  /*0x124*/ u8        maelstromTimer;
  /*0x125*/ u8        _unused_0x125;// ?? Might be afterburner timer or ultralisk roar timer
  /*0x126*/ u8        acidSporeCount;
  /*0x127*/ u8        acidSporeTime[9];
    } status;
/*0x130*/ u16   bulletBehaviour3by3AttackSequence;  // Counts up for the number of bullets shot by a unit using
                                                    // this weapon behaviour and resets after it reaches 12

    u16   _padding_0x132;   // 2-byte padding

/*0x134*/ void  *pAI;        // pointer to AI class, we're not using this though  // official name
/*0x138*/ u16   airStrength;
/*0x13A*/ u16   groundStrength;
    struct
    {         // Official names are "posSortXL, posSortXR, posSortYT, posSortYB"
      u32 left, right, top, bottom; // Ordering for unit boundries in unit finder for binary search
    } finder;
/*0x14C*/ u8    _repulseUnknown;    // @todo Unknown
/*0x14D*/ u8    repulseAngle;       // updated only when air unit is being pushed
/*0x14E*/ u8    driftPosX;          //  (mapsizex/1.5 max)// officially "bRepMtxX"   // repulse matrix X/Y
/*0x14F*/ u8    driftPosY;          //  (mapsizex/1.5 max)// "bRepMtxY"

////////////////////////////////////////////////////////////////////
// Official Broodwar methods (from beta), ignore these
/*
    bool  IsAddOn() const;
    bool  IsATransport() const;
    bool  IsBuilding() const; // Checks unit status flags
    bool  IsBuildingEx() const;   // Checks unit type (special ability flags)
    bool  IsBurrower() const;
    bool  IsCarrier() const;
    bool  IsCarrierType() const;
    bool  IsCloakable() const;
    bool  IsCloaker() const;
    bool  IsCompleted() const;
    bool  IsConstructing() const;
    bool  IsDead() const;
    bool  IsDoodad() const;
    bool  IsDoorType() const;
    bool  IsFighterType() const;
    bool  IsGhostType() const;
    bool  IsGoliathHead() const;
    bool  IsHallucination() const;
    bool  IsHidden() const;
    bool  IsJuiceMaker() const; // same as IsPylon
    bool  IsMedic() const;
    bool  IsMobileBuilding() const;
    bool  IsMoving() const;
    bool  IsNydusCanal() const;
    bool  IsPowerup() const;
    bool  IsPylonType() const;
    bool  IsQueenType() const;
    bool  IsRallyer() const;
    bool  IsReaver() const;
    bool  IsRevealer() const;
    bool  IsResourceDest() const;
    bool  IsResourceSrc() const;
    bool  IsScanner() const;
    bool  IsSelected() const;
    bool  IsShieldBattery() const;
    bool  IsSiloType() const;
    bool  IsTemplar() const;
    u16   IsTrainingUnit(int id) const;
    bool  IsTurret() const;
    bool  IsVulture() const;
    bool  IsWorker() const;
    bool  IsZergBldgUpgrading() const;
    bool  IsZergTownhall() const;
    
    bool  HasAI() const;
    CAIControl  *GetAI() const;
    
    CUnit *GetAddOn() const;
    u16   GetAddOn2BldType() const;
    CUnit *GetAttached() const;
    u8    GetBGOrder() const;
    int   GetFixedMaxHP() const;
    int   GetHangarCapacity() const;
    int   GetMaxHP() const;
    int   GetNumInterceptors() const;
    u8    GetOrder() const;
    u8    GetOwner() const;
    u16   GetType() const;
    u16   GetUnitID() const;
    u8    GetWeaponGndEx() const;

    bool  HasGas() const;
    bool  HasMinerals() const;
    bool  HasNuke() const;
    bool  HasPath() const;

    bool  CompletionCounted() const;
    bool  ExistenceCounted() const;
    COrder  *PeekOrder() const;
    CUnit *Target() const;
    bool  CantBeHit() const;
    bool  AtMoveTarget() const;
    bool  CanEnterTransport(CUnit *trans) const;
    bool  InTransport() const;
    int   UnitPlaceboxWidth() const;  // Also has a global version taking unit type as param
    int   UnitPlaceboxHeight() const; // Also has a global version taking unit type as param
    int   ProvidedFood() const;
    int   TownSpot() const;   // resource base ID (0-250)
    int   X() const;
    int   Y() const;
    void  FindFree_FromUnit(Position *pResult, CUnit *) const;
    bool  CanTarget(CUnit *pTarg, bool) const;

    void  DispatchEnterTransport();
    void  DispatchDecloak();
    void  RunBGOrders();
    void  RunTransportOrders();
    void  RunBGTransportOrders();
    SetOrderEx
    AppendOrderEx
    void FixupAIPointer(bool);
    void UnfixupAIPointer(bool);
    void RemoveFromStatusBar();
    void AddToHarvestWaitingList(CUnit *pWorker);
    void PlaceUnplaceBldg(short x, short y, bool);

    bool  StdTargetTracking();
    void  PathCalcMove();
    bool  CheckResolveCollision();
    bool  SetMoveTarget_CUnit(CUnit *pUnit);
    bool  SetMoveTarget_xy(int x, int y);
    bool  ApproachMoveTarget_CUnit(CUnit *pUnit);
    bool  ApproachMoveTarget_xy(int x, int y);
    void  SetSubTarget(int x, int y);

    CUnit *NextNode() const;
    CUnit *PrevNode() const;
    bool  OnUsedList() const;   // scrapped (used in debug)
    bool  OnTransList() const;  // scrapped
    bool  OnFreeList() const;   // scrapped
    bool  OnDeadList() const;   // scrapped

    */
  };

  static_assert( sizeof(CUnit) == 336, "BW::CUnit is incorrect." );
};
#pragma pack()